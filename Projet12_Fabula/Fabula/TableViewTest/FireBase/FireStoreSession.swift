//
//  FireProtocol.swift
//  Fabula
//
//  Created by RaphaÃ«l Goupille on 12/02/2022.
//

import Foundation
import FirebaseFirestore

protocol FireStoreSession {
    /// get data from firebase
    func getDocuments(dataRequest: String, callback: @escaping ([[String: Any]]?, NetworkError?) -> Void)
    /// get new data when end is reached in tableview
    func getNewDocuments(dataRequest: String, callback: @escaping ([[String: Any]]?, NetworkError?) -> Void)
    /// use by searchViewModel to get all anecdotes
    func getAllDocuments(dataRequest: String, callback: @escaping ([[String: Any]]?, NetworkError?) -> Void)
    /// retrieve user information to be able to save the comments
    func getUserInfo(dataRequest: String, userId: String, callback: @escaping ([String: Any]?, NetworkError?) -> Void)
    /// used by detailAnecdoteViewModel to get the comments for the specific anecdote
    func readComments(dataRequest: String, anecdoteId: String, callback: @escaping ([[String: Any]]?, NetworkError?) -> Void)
    /// retrieve quizz category and theme for HomeQuizzViewModel
    func getCategoryQuizz(dataRequest: String, callback: @escaping ([[String : Any]]?, NetworkError?) -> Void)
    /// retrieve quizzs questions and answer for TestQuizzViewModel
    func getQuizzs(title: String, dataRequest: String, callback: @escaping([[String : Any]]?, NetworkError?) -> Void)
    
    /// Use by detailanecdote to save comment
    func save(commentToSave: [String: Any], anecdoteId: String, completion: @escaping (Bool) -> ())
    
}

extension FireStoreSession {
    
    func getDocuments(dataRequest: String, callback: @escaping (QuerySnapshot?, Error?) -> Void) {
    }
    
    func getNewDocuments(dataRequest: String, callback: @escaping ([[String: Any]]?, NetworkError?) -> Void) {
    }
    
    func getAllDocuments(dataRequest: String, callback: @escaping ([[String: Any]]?, NetworkError?) -> Void) {
    }
    
    func getUserInfo(dataRequest: String, userId: String, callback: @escaping ([String: Any]?, NetworkError?) -> Void) {
    }
    
    func readComments(dataRequest: String, anecdoteId: String, callback: @escaping ([[String: Any]]?, NetworkError?) -> Void) {
    }
    
    func getCategoryQuizz(dataRequest: String, callback: @escaping ([[String : Any]]?, NetworkError?) -> Void) {
    }
    
    func getQuizzs(title: String, dataRequest: String, callback: @escaping([[String : Any]]?, NetworkError?) -> Void) {
    }
    
    func save(commentToSave: [String: Any], anecdoteId: String, completion: @escaping (Bool) -> ()) {
    }
}
/// generic session used to retrieve info from FireStore
final class DataSession: FireStoreSession {
    // keep track of lastSnapshot to retrieve new data starting from this snapshot
    private var lastSnapshot: QueryDocumentSnapshot?
    private let dataBase = Firestore.firestore()
    
    func getDocuments(dataRequest: String, callback: @escaping ([[String : Any]]?, NetworkError?) -> Void) {
        let docRef = dataBase.collection(dataRequest).order(by: "date", descending: true).limit(to: 5)
        
        docRef.getDocuments { snapshot, error in
            guard let data = snapshot?.documents, error == nil else {
                callback(nil, NetworkError.errorOccured)
                return
            }
            if snapshot?.metadata.isFromCache == true {
                callback(nil, NetworkError.noConnection) }
            var dictionnary = [[String: Any]]()
            for x in 0 ..< data.count {
                var dataDict = data[x].data()
                // get the id of the document generated by firebase
                let id = data[x].documentID as Any
                dataDict["id"] = id
                // if there is a date, convert the date in Date
                if data[x].data()["date"] != nil {
                    let fireDate = (data[x].data()["date"] as? Timestamp)?.dateValue() ?? Date()
                    dataDict["Date"] = fireDate
                }
                dictionnary.append(dataDict)
            }
            callback(dictionnary, nil)
            self.lastSnapshot = snapshot?.documents.last
        }
    }
    
    func getNewDocuments(dataRequest: String, callback: @escaping ([[String : Any]]?, NetworkError?) -> Void) {
        guard let lastSnapshot = lastSnapshot else { return }
        let docRef = dataBase.collection(dataRequest).order(by: "date", descending: true).limit(to: 5).start(afterDocument: lastSnapshot)
        docRef.getDocuments { snapshot, error in
            guard let data = snapshot?.documents, error == nil else {
                callback(nil, NetworkError.errorOccured)
                return
            }
            if snapshot?.metadata.isFromCache == true {
                callback(nil, NetworkError.noConnection)
            }
            var dictionnary = [[String: Any]]()
            for x in 0 ..< data.count {
                var dataDict = data[x].data()
                // get the id of the document generated by firebase
                let id = data[x].documentID as Any
                dataDict["id"] = id
                // if there is a date, convert the date in Date
                if data[x].data()["date"] != nil {
                    let fireDate = (data[x].data()["date"] as? Timestamp)?.dateValue() ?? Date()
                    dataDict["Date"] = fireDate
                }
                dictionnary.append(dataDict)
            }
            callback(dictionnary, nil)
            self.lastSnapshot = snapshot?.documents.last
        }
    }
    
    func getAllDocuments(dataRequest: String, callback: @escaping ([[String : Any]]?, NetworkError?) -> Void) {
        let docRef = dataBase.collection(dataRequest).order(by: "date", descending: true)
        docRef.getDocuments { snapshot, error in
            guard let data = snapshot?.documents, error == nil else {
                callback(nil, NetworkError.errorOccured)
                return
            }
            if snapshot?.metadata.isFromCache == true {
                callback(nil, NetworkError.noConnection)
            }
            var dictionnary = [[String: Any]]()
            for x in 0 ..< data.count {
                var anecdoteDict = data[x].data()
                // get the id of the document generated by firebase
                let id = data[x].documentID as Any
                anecdoteDict["id"] = id
                // convert the date in Date
                if data[x].data()["date"] != nil {
                    let fireDate = (data[x].data()["date"] as? Timestamp)?.dateValue() ?? Date()
                    anecdoteDict["Date"] = fireDate
                }
                dictionnary.append(anecdoteDict)
            }
            callback(dictionnary, nil)
        }
    }
    
    func getUserInfo(dataRequest: String, userId: String, callback: @escaping ([String: Any]?, NetworkError?) -> Void) {
        let docRef = dataBase.collection(dataRequest).whereField("userId", isEqualTo: userId)
        docRef.getDocuments { snapshot, error in
            guard let data = snapshot?.documents
                    , error == nil else {
                        callback(nil, NetworkError.errorOccured)
                        return
                    }
            let dictionary = data[0].data()
            callback(dictionary, nil)
        }
    }
    
    func readComments(dataRequest: String, anecdoteId: String, callback: @escaping ([[String : Any]]?, NetworkError?) -> Void) {
        var firestoreResult = [[String: Any]]()
        let docRef = dataBase.collection(dataRequest).whereField("anecdoteId", isEqualTo: anecdoteId)
        docRef.getDocuments { snapshot, error in
            guard let data = snapshot?.documents
                    , error == nil else {
                        callback(nil, NetworkError.errorOccured)
                        return
                    }
            for i in 0 ..< data.count {
                var dictionary = data[i].data()
                let fireDate = (data[i].data()["date"] as? Timestamp)?.dateValue() ?? Date()
                dictionary["date"] = fireDate
                firestoreResult.append(dictionary)
            }
            callback(firestoreResult, nil)
        }
    }
    
    func getCategoryQuizz(dataRequest: String, callback: @escaping ([[String : Any]]?, NetworkError?) -> Void) {
        var firestoreResult = [[String: Any]]()
        let docRef = dataBase.collection(dataRequest)
        docRef.getDocuments { snapshot, error in
            guard let data = snapshot?.documents, error == nil else {
                callback(nil, NetworkError.errorOccured)
                return }
            for i in 0 ..< data.count {
                let dictionary = data[i].data()
                firestoreResult.append(dictionary)
            }
            callback(firestoreResult, nil)
        }
    }
    
    func getQuizzs(title: String, dataRequest: String, callback: @escaping([[String : Any]]?, NetworkError?) -> Void) {
        var firestoreResult = [[String: Any]]()
        let docRef = dataBase.collection(dataRequest).whereField("title", isEqualTo: title)
        docRef.getDocuments { snapshot, error in
            guard let data = snapshot?.documents, error == nil else {
                callback(nil, NetworkError.errorOccured)
                return
            }
            for i in 0 ..< data.count {
                let dictionary = data[i].data()
                firestoreResult.append(dictionary)
            }
            callback(firestoreResult, nil)
        }
    }
    
    func save(commentToSave: [String: Any], anecdoteId: String, completion: @escaping (Bool) -> ()) {
        dataBase.collection(DataRequest.comments.rawValue).document().setData(commentToSave) { err in
            if let err = err {
                print("Error writing document: \(err)")
            } else {
                print("Document successfully written!")
            }
            // when comment is save, retrieve comments to update tableview
            completion(true)
        }
    }
    
}
